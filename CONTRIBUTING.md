# Contributing to MicroShard UUID

First off, thank you for considering contributing to MicroShard UUID! üöÄ

This repository is a **monorepo** containing implementations for multiple languages and database extensions. We welcome contributions of all kinds: from simple typo fixes to new language ports or database extensions.

## üìÇ Repository Structure

Before you start, please familiarize yourself with the structure:

*   **`implementations/`**: Client libraries (Python, Go, JS, Rust).
*   **`db-extensions/`**: Database-specific logic (Postgres, SQLite, DuckDB, ClickHouse).
*   **`docs/`**: Documentation and RFC specifications.

---

## ‚ö†Ô∏è Core Architecture Rules (READ THIS FIRST)

MicroShard relies on a strict **Bit Layout** to ensure compatibility across all languages and databases.

**Do NOT modify the following without opening a Discussion first:**
1.  **Time:** Must be 54 bits (Microsecond precision).
2.  **Shard ID:** Must be 32 bits.
3.  **Randomness:** Must be 36 bits.
4.  **Version/Variant:** Must adhere to UUIDv8 (RFC 9562).

Any PR that alters this bit packing logic without a corresponding RFC update will be rejected to prevent breaking cross-system compatibility.

---

## üõ†Ô∏è Development Guidelines

### 1. Language Standards
We strive for idiomatic code in every language.

*   **Python:** Follow PEP 8. Use `black` for formatting and `pytest` for testing.
*   **Go:** Run `go fmt` and `go vet` before committing. Use standard `testing` package.
*   **Rust:** Use `cargo fmt` and `cargo clippy`. Ensure no warnings in release mode.
*   **JavaScript/TypeScript:** Use Prettier and ESLint.
*   **SQL:** Uppercase keywords (`SELECT`, `FROM`), lowercase identifiers (`user_id`).

### 2. Testing Requirements
Because this is a security and identity library, **correctness is paramount**.
*   **Unit Tests:** Every PR must include unit tests.
*   **Collision Tests:** If modifying generation logic, include a test that generates 100k+ IDs to check for local collisions.
*   **Interoperability:** If adding a new language, ensure it can decode IDs generated by the reference implementation (Python).

---

## üíæ Contributing to Database Extensions

When working on `db-extensions/`:
1.  **Performance is King:** Use bitwise operations over string parsing whenever possible.
2.  **Zero External Deps:** Extensions should ideally run without requiring root access or compiling complex C libraries (unless absolutely necessary, like for SQLite).
3.  **Migration Path:** Always provide a `microshard_from_micros` equivalent to allow backfilling data.

---

## üìù Commit Messages

We follow **Conventional Commits**. Please structure your commit messages as follows:

```text
<type>(<scope>): <description>

[optional body]
```

**Types:**
*   `feat`: A new feature (e.g., `feat(rust): add serde support`)
*   `fix`: A bug fix (e.g., `fix(pg): correct bitshift in extraction`)
*   `docs`: Documentation only changes
*   `perf`: A code change that improves performance
*   `test`: Adding missing tests or correcting existing tests

**Scopes:**
`python`, `go`, `rust`, `js`, `postgres`, `sqlite`, `duckdb`, `core`

**Example:**
> `feat(duckdb): implement hugeint extraction logic`

---

## üì• Pull Request Process

1.  **Fork** the repository and create your branch from `main`.
2.  If you've added code that should be tested, add tests.
3.  Ensure the test suite passes.
4.  Update the `README.md` in the specific subdirectory if you changed the API.
5.  Issue that Pull Request!

## üêû Found a Bug?

If you find a bug in the source code or a mistake in the documentation, you can help us by [submitting an issue](../issues) to the GitHub Repository. Even better, you can submit a Pull Request with a fix.

## üìÑ License

By contributing, you agree that your contributions will be licensed under its MIT License.